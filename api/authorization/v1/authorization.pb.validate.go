// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/authorization/v1/authorization.proto

package authv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ResultReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResultReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResultReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResultReplyMultiError, or
// nil if none found.
func (m *ResultReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ResultReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return ResultReplyMultiError(errors)
	}

	return nil
}

// ResultReplyMultiError is an error wrapping multiple validation errors
// returned by ResultReply.ValidateAll() if the designated constraints aren't met.
type ResultReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultReplyMultiError) AllErrors() []error { return m }

// ResultReplyValidationError is the validation error returned by
// ResultReply.Validate if the designated constraints aren't met.
type ResultReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultReplyValidationError) ErrorName() string { return "ResultReplyValidationError" }

// Error satisfies the builtin error interface
func (e ResultReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResultReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultReplyValidationError{}

// Validate checks the field values on EnforceReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnforceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnforceReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnforceReqMultiError, or
// nil if none found.
func (m *EnforceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EnforceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSub()) < 1 {
		err := EnforceReqValidationError{
			field:  "Sub",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetObj()) < 1 {
		err := EnforceReqValidationError{
			field:  "Obj",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAct()) < 1 {
		err := EnforceReqValidationError{
			field:  "Act",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EnforceReqMultiError(errors)
	}

	return nil
}

// EnforceReqMultiError is an error wrapping multiple validation errors
// returned by EnforceReq.ValidateAll() if the designated constraints aren't met.
type EnforceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnforceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnforceReqMultiError) AllErrors() []error { return m }

// EnforceReqValidationError is the validation error returned by
// EnforceReq.Validate if the designated constraints aren't met.
type EnforceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnforceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnforceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnforceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnforceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnforceReqValidationError) ErrorName() string { return "EnforceReqValidationError" }

// Error satisfies the builtin error interface
func (e EnforceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnforceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnforceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnforceReqValidationError{}

// Validate checks the field values on GetRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRolesForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRolesForUserReqMultiError, or nil if none found.
func (m *GetRolesForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRolesForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := GetRolesForUserReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRolesForUserReqMultiError(errors)
	}

	return nil
}

// GetRolesForUserReqMultiError is an error wrapping multiple validation errors
// returned by GetRolesForUserReq.ValidateAll() if the designated constraints
// aren't met.
type GetRolesForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRolesForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRolesForUserReqMultiError) AllErrors() []error { return m }

// GetRolesForUserReqValidationError is the validation error returned by
// GetRolesForUserReq.Validate if the designated constraints aren't met.
type GetRolesForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRolesForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRolesForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRolesForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRolesForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRolesForUserReqValidationError) ErrorName() string {
	return "GetRolesForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetRolesForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRolesForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRolesForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRolesForUserReqValidationError{}

// Validate checks the field values on GetRolesForUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRolesForUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRolesForUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRolesForUserReplyMultiError, or nil if none found.
func (m *GetRolesForUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRolesForUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetRolesForUserReplyMultiError(errors)
	}

	return nil
}

// GetRolesForUserReplyMultiError is an error wrapping multiple validation
// errors returned by GetRolesForUserReply.ValidateAll() if the designated
// constraints aren't met.
type GetRolesForUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRolesForUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRolesForUserReplyMultiError) AllErrors() []error { return m }

// GetRolesForUserReplyValidationError is the validation error returned by
// GetRolesForUserReply.Validate if the designated constraints aren't met.
type GetRolesForUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRolesForUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRolesForUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRolesForUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRolesForUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRolesForUserReplyValidationError) ErrorName() string {
	return "GetRolesForUserReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetRolesForUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRolesForUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRolesForUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRolesForUserReplyValidationError{}

// Validate checks the field values on GetUsersForRoleReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUsersForRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUsersForRoleReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUsersForRoleReqMultiError, or nil if none found.
func (m *GetUsersForRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUsersForRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRole()) < 1 {
		err := GetUsersForRoleReqValidationError{
			field:  "Role",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUsersForRoleReqMultiError(errors)
	}

	return nil
}

// GetUsersForRoleReqMultiError is an error wrapping multiple validation errors
// returned by GetUsersForRoleReq.ValidateAll() if the designated constraints
// aren't met.
type GetUsersForRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUsersForRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUsersForRoleReqMultiError) AllErrors() []error { return m }

// GetUsersForRoleReqValidationError is the validation error returned by
// GetUsersForRoleReq.Validate if the designated constraints aren't met.
type GetUsersForRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUsersForRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUsersForRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUsersForRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUsersForRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUsersForRoleReqValidationError) ErrorName() string {
	return "GetUsersForRoleReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetUsersForRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUsersForRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUsersForRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUsersForRoleReqValidationError{}

// Validate checks the field values on GetUsersForRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUsersForRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUsersForRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUsersForRoleReplyMultiError, or nil if none found.
func (m *GetUsersForRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUsersForRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetUsersForRoleReplyMultiError(errors)
	}

	return nil
}

// GetUsersForRoleReplyMultiError is an error wrapping multiple validation
// errors returned by GetUsersForRoleReply.ValidateAll() if the designated
// constraints aren't met.
type GetUsersForRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUsersForRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUsersForRoleReplyMultiError) AllErrors() []error { return m }

// GetUsersForRoleReplyValidationError is the validation error returned by
// GetUsersForRoleReply.Validate if the designated constraints aren't met.
type GetUsersForRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUsersForRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUsersForRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUsersForRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUsersForRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUsersForRoleReplyValidationError) ErrorName() string {
	return "GetUsersForRoleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetUsersForRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUsersForRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUsersForRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUsersForRoleReplyValidationError{}

// Validate checks the field values on AddRoleForUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddRoleForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddRoleForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddRoleForUserReqMultiError, or nil if none found.
func (m *AddRoleForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddRoleForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := AddRoleForUserReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRole()) < 1 {
		err := AddRoleForUserReqValidationError{
			field:  "Role",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddRoleForUserReqMultiError(errors)
	}

	return nil
}

// AddRoleForUserReqMultiError is an error wrapping multiple validation errors
// returned by AddRoleForUserReq.ValidateAll() if the designated constraints
// aren't met.
type AddRoleForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddRoleForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddRoleForUserReqMultiError) AllErrors() []error { return m }

// AddRoleForUserReqValidationError is the validation error returned by
// AddRoleForUserReq.Validate if the designated constraints aren't met.
type AddRoleForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddRoleForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddRoleForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddRoleForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddRoleForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddRoleForUserReqValidationError) ErrorName() string {
	return "AddRoleForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddRoleForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddRoleForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddRoleForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddRoleForUserReqValidationError{}

// Validate checks the field values on HasRoleForUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HasRoleForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HasRoleForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HasRoleForUserReqMultiError, or nil if none found.
func (m *HasRoleForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HasRoleForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := HasRoleForUserReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRole()) < 1 {
		err := HasRoleForUserReqValidationError{
			field:  "Role",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return HasRoleForUserReqMultiError(errors)
	}

	return nil
}

// HasRoleForUserReqMultiError is an error wrapping multiple validation errors
// returned by HasRoleForUserReq.ValidateAll() if the designated constraints
// aren't met.
type HasRoleForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HasRoleForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HasRoleForUserReqMultiError) AllErrors() []error { return m }

// HasRoleForUserReqValidationError is the validation error returned by
// HasRoleForUserReq.Validate if the designated constraints aren't met.
type HasRoleForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HasRoleForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HasRoleForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HasRoleForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HasRoleForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HasRoleForUserReqValidationError) ErrorName() string {
	return "HasRoleForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e HasRoleForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHasRoleForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HasRoleForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HasRoleForUserReqValidationError{}

// Validate checks the field values on HasRoleForUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HasRoleForUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HasRoleForUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HasRoleForUserReplyMultiError, or nil if none found.
func (m *HasRoleForUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HasRoleForUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return HasRoleForUserReplyMultiError(errors)
	}

	return nil
}

// HasRoleForUserReplyMultiError is an error wrapping multiple validation
// errors returned by HasRoleForUserReply.ValidateAll() if the designated
// constraints aren't met.
type HasRoleForUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HasRoleForUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HasRoleForUserReplyMultiError) AllErrors() []error { return m }

// HasRoleForUserReplyValidationError is the validation error returned by
// HasRoleForUserReply.Validate if the designated constraints aren't met.
type HasRoleForUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HasRoleForUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HasRoleForUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HasRoleForUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HasRoleForUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HasRoleForUserReplyValidationError) ErrorName() string {
	return "HasRoleForUserReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HasRoleForUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHasRoleForUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HasRoleForUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HasRoleForUserReplyValidationError{}

// Validate checks the field values on AddPermissionForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddPermissionForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddPermissionForUserReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddPermissionForUserReqMultiError, or nil if none found.
func (m *AddPermissionForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddPermissionForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := AddPermissionForUserReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetObj()) < 1 {
		err := AddPermissionForUserReqValidationError{
			field:  "Obj",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAct()) < 1 {
		err := AddPermissionForUserReqValidationError{
			field:  "Act",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddPermissionForUserReqMultiError(errors)
	}

	return nil
}

// AddPermissionForUserReqMultiError is an error wrapping multiple validation
// errors returned by AddPermissionForUserReq.ValidateAll() if the designated
// constraints aren't met.
type AddPermissionForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddPermissionForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddPermissionForUserReqMultiError) AllErrors() []error { return m }

// AddPermissionForUserReqValidationError is the validation error returned by
// AddPermissionForUserReq.Validate if the designated constraints aren't met.
type AddPermissionForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddPermissionForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddPermissionForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddPermissionForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddPermissionForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddPermissionForUserReqValidationError) ErrorName() string {
	return "AddPermissionForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddPermissionForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddPermissionForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddPermissionForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddPermissionForUserReqValidationError{}

// Validate checks the field values on AddPermissionForRoleReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddPermissionForRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddPermissionForRoleReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddPermissionForRoleReqMultiError, or nil if none found.
func (m *AddPermissionForRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddPermissionForRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRole()) < 1 {
		err := AddPermissionForRoleReqValidationError{
			field:  "Role",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetObj()) < 1 {
		err := AddPermissionForRoleReqValidationError{
			field:  "Obj",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAct()) < 1 {
		err := AddPermissionForRoleReqValidationError{
			field:  "Act",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddPermissionForRoleReqMultiError(errors)
	}

	return nil
}

// AddPermissionForRoleReqMultiError is an error wrapping multiple validation
// errors returned by AddPermissionForRoleReq.ValidateAll() if the designated
// constraints aren't met.
type AddPermissionForRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddPermissionForRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddPermissionForRoleReqMultiError) AllErrors() []error { return m }

// AddPermissionForRoleReqValidationError is the validation error returned by
// AddPermissionForRoleReq.Validate if the designated constraints aren't met.
type AddPermissionForRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddPermissionForRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddPermissionForRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddPermissionForRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddPermissionForRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddPermissionForRoleReqValidationError) ErrorName() string {
	return "AddPermissionForRoleReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddPermissionForRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddPermissionForRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddPermissionForRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddPermissionForRoleReqValidationError{}

// Validate checks the field values on GetPermissionsForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPermissionsForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPermissionsForUserReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPermissionsForUserReqMultiError, or nil if none found.
func (m *GetPermissionsForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPermissionsForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := GetPermissionsForUserReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPermissionsForUserReqMultiError(errors)
	}

	return nil
}

// GetPermissionsForUserReqMultiError is an error wrapping multiple validation
// errors returned by GetPermissionsForUserReq.ValidateAll() if the designated
// constraints aren't met.
type GetPermissionsForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPermissionsForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPermissionsForUserReqMultiError) AllErrors() []error { return m }

// GetPermissionsForUserReqValidationError is the validation error returned by
// GetPermissionsForUserReq.Validate if the designated constraints aren't met.
type GetPermissionsForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPermissionsForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPermissionsForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPermissionsForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPermissionsForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPermissionsForUserReqValidationError) ErrorName() string {
	return "GetPermissionsForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetPermissionsForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPermissionsForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPermissionsForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPermissionsForUserReqValidationError{}

// Validate checks the field values on GetPermissionsForUserReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPermissionsForUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPermissionsForUserReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPermissionsForUserReplyMultiError, or nil if none found.
func (m *GetPermissionsForUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPermissionsForUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPerm() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPermissionsForUserReplyValidationError{
						field:  fmt.Sprintf("Perm[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPermissionsForUserReplyValidationError{
						field:  fmt.Sprintf("Perm[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPermissionsForUserReplyValidationError{
					field:  fmt.Sprintf("Perm[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPermissionsForUserReplyMultiError(errors)
	}

	return nil
}

// GetPermissionsForUserReplyMultiError is an error wrapping multiple
// validation errors returned by GetPermissionsForUserReply.ValidateAll() if
// the designated constraints aren't met.
type GetPermissionsForUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPermissionsForUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPermissionsForUserReplyMultiError) AllErrors() []error { return m }

// GetPermissionsForUserReplyValidationError is the validation error returned
// by GetPermissionsForUserReply.Validate if the designated constraints aren't met.
type GetPermissionsForUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPermissionsForUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPermissionsForUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPermissionsForUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPermissionsForUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPermissionsForUserReplyValidationError) ErrorName() string {
	return "GetPermissionsForUserReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetPermissionsForUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPermissionsForUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPermissionsForUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPermissionsForUserReplyValidationError{}

// Validate checks the field values on DeletePermissionForUserReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePermissionForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePermissionForUserReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePermissionForUserReqMultiError, or nil if none found.
func (m *DeletePermissionForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePermissionForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := DeletePermissionForUserReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetObj()) < 1 {
		err := DeletePermissionForUserReqValidationError{
			field:  "Obj",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAct()) < 1 {
		err := DeletePermissionForUserReqValidationError{
			field:  "Act",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePermissionForUserReqMultiError(errors)
	}

	return nil
}

// DeletePermissionForUserReqMultiError is an error wrapping multiple
// validation errors returned by DeletePermissionForUserReq.ValidateAll() if
// the designated constraints aren't met.
type DeletePermissionForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePermissionForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePermissionForUserReqMultiError) AllErrors() []error { return m }

// DeletePermissionForUserReqValidationError is the validation error returned
// by DeletePermissionForUserReq.Validate if the designated constraints aren't met.
type DeletePermissionForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePermissionForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePermissionForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePermissionForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePermissionForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePermissionForUserReqValidationError) ErrorName() string {
	return "DeletePermissionForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePermissionForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePermissionForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePermissionForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePermissionForUserReqValidationError{}

// Validate checks the field values on DeletePermissionForRoleReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePermissionForRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePermissionForRoleReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePermissionForRoleReqMultiError, or nil if none found.
func (m *DeletePermissionForRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePermissionForRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRole()) < 1 {
		err := DeletePermissionForRoleReqValidationError{
			field:  "Role",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetObj()) < 1 {
		err := DeletePermissionForRoleReqValidationError{
			field:  "Obj",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAct()) < 1 {
		err := DeletePermissionForRoleReqValidationError{
			field:  "Act",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePermissionForRoleReqMultiError(errors)
	}

	return nil
}

// DeletePermissionForRoleReqMultiError is an error wrapping multiple
// validation errors returned by DeletePermissionForRoleReq.ValidateAll() if
// the designated constraints aren't met.
type DeletePermissionForRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePermissionForRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePermissionForRoleReqMultiError) AllErrors() []error { return m }

// DeletePermissionForRoleReqValidationError is the validation error returned
// by DeletePermissionForRoleReq.Validate if the designated constraints aren't met.
type DeletePermissionForRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePermissionForRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePermissionForRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePermissionForRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePermissionForRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePermissionForRoleReqValidationError) ErrorName() string {
	return "DeletePermissionForRoleReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePermissionForRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePermissionForRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePermissionForRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePermissionForRoleReqValidationError{}

// Validate checks the field values on DeleteRoleForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRoleForUserReqMultiError, or nil if none found.
func (m *DeleteRoleForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUid()) < 1 {
		err := DeleteRoleForUserReqValidationError{
			field:  "Uid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRole()) < 1 {
		err := DeleteRoleForUserReqValidationError{
			field:  "Role",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRoleForUserReqMultiError(errors)
	}

	return nil
}

// DeleteRoleForUserReqMultiError is an error wrapping multiple validation
// errors returned by DeleteRoleForUserReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteRoleForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleForUserReqMultiError) AllErrors() []error { return m }

// DeleteRoleForUserReqValidationError is the validation error returned by
// DeleteRoleForUserReq.Validate if the designated constraints aren't met.
type DeleteRoleForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleForUserReqValidationError) ErrorName() string {
	return "DeleteRoleForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRoleForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleForUserReqValidationError{}

// Validate checks the field values on GetPermissionsForUserReply_Perm with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPermissionsForUserReply_Perm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPermissionsForUserReply_Perm with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetPermissionsForUserReply_PermMultiError, or nil if none found.
func (m *GetPermissionsForUserReply_Perm) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPermissionsForUserReply_Perm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Obj

	// no validation rules for Act

	if len(errors) > 0 {
		return GetPermissionsForUserReply_PermMultiError(errors)
	}

	return nil
}

// GetPermissionsForUserReply_PermMultiError is an error wrapping multiple
// validation errors returned by GetPermissionsForUserReply_Perm.ValidateAll()
// if the designated constraints aren't met.
type GetPermissionsForUserReply_PermMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPermissionsForUserReply_PermMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPermissionsForUserReply_PermMultiError) AllErrors() []error { return m }

// GetPermissionsForUserReply_PermValidationError is the validation error
// returned by GetPermissionsForUserReply_Perm.Validate if the designated
// constraints aren't met.
type GetPermissionsForUserReply_PermValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPermissionsForUserReply_PermValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPermissionsForUserReply_PermValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPermissionsForUserReply_PermValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPermissionsForUserReply_PermValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPermissionsForUserReply_PermValidationError) ErrorName() string {
	return "GetPermissionsForUserReply_PermValidationError"
}

// Error satisfies the builtin error interface
func (e GetPermissionsForUserReply_PermValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPermissionsForUserReply_Perm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPermissionsForUserReply_PermValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPermissionsForUserReply_PermValidationError{}
